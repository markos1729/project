src/JoinResults.cpp:    return nextpos > (BUFFER_SIZE / sizeof(unsigned int) - 2);
src/JoinResults.cpp:        ResultNode *next = temp->next;
src/JoinResults.cpp:        if ( head->addTuple(rowid1, rowid2) ){
src/JoinResults.cpp:        if ( ! cur->isFull() ){
src/JoinResults.cpp:            if ( cur->addTuple(rowid1, rowid2) ){
src/JoinResults.cpp:            temp->next = cur;
src/JoinResults.cpp:            if ( cur->addTuple(rowid1, rowid2) ){
src/JoinResults.cpp:        current->printRowIds();
src/JoinResults.cpp:        current = current->next;
src/JoinResults.cpp:    rid = curr->buffer[pos];
src/JoinResults.cpp:    sid = curr->buffer[pos+1];
src/JoinResults.cpp:	if (pos >= curr->nextpos) curr = curr->next;
src/RadixHashJoin.cpp:...0000000001111 (take last 4 bits for H1) = value & ((1<<H1_N)-1)
src/RadixHashJoin.cpp:...0000000110000 (take the next 4/2=2 bits for H2) = value & (((1<<H2_N)-1)^((1<<H1_N)-1))
src/RadixHashJoin.cpp:		^		  -> ......0000000110000 !!!
src/RadixHashJoin.cpp://TODO: remove this? -> unsigned int H2_OLD_MAY_REPLACE_H1_SEE_EXPLANATION(intField value) { return value & ((1 << H2_N) - 1); }
src/RadixHashJoin.cpp:unsigned int H2(intField value) { return ( value & ( ((1 << (H1_N + H2_N)) - 1) ^ ( (1 << H1_N) - 1) ) ) >> H1_N; }
src/RadixHashJoin.cpp:	for (unsigned int i = 0 ; i < I->getNumberOfBuckets() ; i++) {
src/RadixHashJoin.cpp:		CHECK ( indexRelation(I->getJoinFieldBucket(i), I->getBucketSize(i), chain, table) , "indexing of a bucket failed", delete[] chain; delete[] table; delete result; return NULL; )
src/RadixHashJoin.cpp:		CHECK ( probeResults(L->getJoinFieldBucket(i), L->getRowIdsBucket(i), I->getJoinFieldBucket(i), I->getRowIdsBucket(i), chain, table, L->getBucketSize(i), result, saveLfirst) , "probing a bucket for results failed", delete[] chain; delete[] table; delete result; return NULL; )
src/RadixHashJoin.cpp:    for (unsigned int i = bucketSize ; i > 0 ; --i) {
src/RadixHashJoin.cpp:        unsigned int h = H2(bucketJoinField[i - 1]);
src/RadixHashJoin.cpp:        else last[h] = chain[last[h] - 1] = i;
src/RadixHashJoin.cpp:			if (LbucketJoinField[i] == IbucketJoinField[chainIndex - 1]) {
src/RadixHashJoin.cpp:			    if (saveLfirst) result->addTuple(IbucketRowIds[chainIndex - 1], LbucketRowIds[i]);
src/RadixHashJoin.cpp:			    else result->addTuple(LbucketRowIds[i], IbucketRowIds[chainIndex - 1]);
src/RadixHashJoin.cpp:			chainIndex = chain[chainIndex - 1];
src/Relation.cpp:    if (this->getSize() == 0 || rowids == NULL || joinField == NULL ) return true;     // nothing to partition
src/Relation.cpp:    // 1) calculate Hist - O(n)
src/Relation.cpp:    // 3) create new re-ordered versions for joinField and rowids based on their bucket_nums - O(n)
src/Relation.cpp:        const unsigned int pos = Psum[bucket_nums[i]] + nextBucketPos[bucket_nums[i]];   // value's position in the re-ordered version
src/Relation.cpp:    // 4) overwrite joinField and rowids with new re-ordered versions of it
src/Relation.cpp:Relation::Relation(unsigned int _size, unsigned int _num_of_columns) : QueryRelation(false), allocatedWithMmap(false), id(-1), size(_size), num_of_columns(_num_of_columns) {
src/Relation.cpp:Relation::Relation(const char* file) : QueryRelation(false), allocatedWithMmap(true), id(-1) {
src/Relation.cpp:    if (fd == -1) throw 0;
src/Relation.cpp:    if (fstat(fd, &sb) == -1) throw 0;
src/Relation.cpp:        if (size > 0) munmap(columns[0] - 2, (size * num_of_columns + 2) * sizeof(intField));
src/Relation.cpp:    IntermediateRelation *result = new IntermediateRelation(this->id, newrowids, count);
src/Relation.cpp:            printf("%6lu", this->getValueAt(projections[i].col_id, i));
src/Relation.cpp:            delete[] iter->second;   // get unsigned int * from <unsigned int, unsigned int *> pair (!) if is necessary!
src/Relation.cpp:        int rel_pos_in_R = -1;
src/Relation.cpp:            if (R[i]->getId() == rel_id){
src/Relation.cpp:        if (rel_pos_in_R == -1) { cerr << "Warning: rel_id or Rlen invalid in performFilter for intermediate" << endl; delete[] field; return NULL; }
src/Relation.cpp:        field[i] = R[rel_pos_in_R]->getValueAt(col_id, fieldrowids[i] - 1);   // (!) -1 because rowids start at 1
src/Relation.cpp:            unsigned int *rids = iter->second;
src/Relation.cpp:            iter->second = newrowids;
src/Relation.cpp:            delete[] iter->second;
src/Relation.cpp:            iter->second = NULL;
src/Relation.cpp:            allrowids[i++] = iter->second;
src/Relation.cpp:            int rel_pos_in_R = -1;
src/Relation.cpp:                if (R[k]->getId() == projections[j].rel_id){
src/Relation.cpp:            if (rel_pos_in_R == -1) { cerr << "Warning: rel_id or Rlen invalid in performSelect for intermediate" << endl; }
src/Relation.cpp:            else printf("%6lu", R[rel_pos_in_R]->getValueAt(projections[j].col_id, allrowids[projections[j].rel_id][i] - 1));   // (!) -1 because rowids start from 1
src/util.cpp:		tail = head->next = new Node(str);
src/util.cpp:		tail->next = new Node(str);
src/util.cpp:		tail = tail->next;
src/util.cpp:		size--;
src/util.cpp:		char *rval = head->str;
src/util.cpp:		size--;
src/util.cpp:		char *rval = head->str;
src/util.cpp:		head = head->next;
